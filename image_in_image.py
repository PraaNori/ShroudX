import time

# -*- coding: utf-8 -*-
"""Imp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g1GgpXdHzvp5Oe0ba5AuQFWgqrYGMEXQ
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2

def Read_image(image_path) :
    image = cv2.imread(image_path)
    return image

def Write_image(image_path,image) :
    cv2.imwrite(image_path,image)

def Show_image(image,title) :
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(title)
    plt.show()


def resize_image(image_path, output_path, width, height) :
    image = Read_image(image_path)
    resized_image = cv2.resize(image, (width, height))
    Write_image(output_path, resized_image)
    print(f"Resized image saved to {output_path}")

def image_to_binary_3D(image):
    binary_image = np.vectorize(lambda x: format(x, '08b'))(image)
    return binary_image

def each_bit(binary_image,index,height,width,color) :
    matrix =[]
    for i in range(height) :
      Line = []
      for j in range(width) :
        cell = []
        for k in range(color) :
          cell.append(binary_image[i][j][k][index])
        Line.append(cell)
      matrix.append(Line)
    return matrix

def Divider(binary_matrix) :
    matrix = []
    height, width, color = binary_matrix.shape

    for i in range(8) :
      matrix.append(each_bit(binary_matrix,i,height,width,color))
    return matrix

def Combiner(index_1,index_2,Matrix,binary_matrix) :
    matrix = []
    height, width, color = binary_matrix.shape

    for i in range(height):
      Line = []
      for j in range(width) :
        cell = []
        for k in range(color) :
          unit = ''
          for l in range(index_1,index_2+1) :
            unit += Matrix[l][i][j][k]
          for x in range(7-index_2+index_1) :
            unit += '0'

          cell.append(unit)
        Line.append(cell)
      matrix.append(Line)
    return matrix

def binary_to_int(binary_string) :
  return int(binary_string, 2)

def making_to_int(binary_matrix) :
    height,width,color = binary_matrix.shape
    number_matrix = []
    for i in range(height) :
       Line = []
       for j in range(width) :
          cell = []
          for k in range(color) :
            unit = binary_to_int(binary_matrix[i][j][k])
            cell.append(unit)
          Line.append(cell)
       number_matrix.append(Line)

    return number_matrix

def hamming_distance(image_path1, image_path2) :
  image1 = Read_image(image_path1)
  image2 = Read_image(image_path2)

  if image1.shape != image2.shape :
    raise ValueError("Images must have the same shape.")

  diff = image1 != image2
  distance = np.count_nonzero(diff)

  return distance

def Triggering_Level (cover_path,secret_path) :
    cover = Read_image(cover_path)
    secret = Read_image(secret_path)
    a,b = cover.shape[:2]
    c,d = secret.shape[:2]
    Level = (a * b) / (c * d)
    if Level * c*d == a * b :
        Level = int(Level)
    else :
        Level = int(Level) + 1

    if Level >= 8 :
        Level = 1
    elif Level < 8 and Level >= 4 :
        Level = 2
    elif Level < 4 and Level >= 2 :
        Level = 4
    else :
        Level = 8
    return Level

def ENCode_lsb(cover_path, secret_paths,some, output_path,Level) :

    cover = Read_image(cover_path)
    numbers,height, width,color = secret_paths.shape[:4]
    cover_height, cover_width = cover.shape[:2]

    Masking_factor = (0xFF << (Level)) & 0xFF

    numbers = int(numbers/Level)

    cover_masked = cover.copy()

    e = 0
    f = 0
    for i in range(numbers * height * width) :
        cover_masked[e, f] = cover_masked[e, f] & Masking_factor
        f += 1
        if f == cover_width :
            f = 0
            e += 1


    secrets = []

    for i in range(numbers) :
        x = Combiner(Level*i,Level*(i+1) - 1,secret_paths,some)
        x = np.array(x)
        ix = making_to_int(x)
        ix = np.array(ix)
        sx = (ix >> (8-Level)).astype(np.uint8)
        secrets.append(sx)

    a = 0
    b = 0
    count = 0;
    for i in range(cover_height) :
        for j in range(cover_width) :
                if count >= numbers * height * width :
                    break
                d = count % numbers
                cover_masked[i,j] |= secrets[d][a,b]

                if d == numbers-1 :
                    b += 1
                count += 1

                if b == width :
                    b = 0
                    a = a+1


    Write_image(output_path, cover_masked)

    print(f"Stego image saved as {output_path}")

    return [numbers,height,width,color]

def DECode_lsb(stego_path, output_path, secret_size,Level) :

    stego = Read_image(stego_path)
    numbers,height,width,color = secret_size[:4]
    stego_height, stego_width = stego.shape[:2]

    deMasking_factor = (0xFF >> (8-Level)) & 0xFF

    secrets = []
    for i in range(numbers) :
        secrets.append(np.zeros((height, width, 3), dtype=np.uint8))

    index = 0
    a = 0
    b = 0
    for i in range(stego_height) :
        for j in range(stego_width) :
            if a >= height :
                break
            s = index % numbers
            secrets[s][a,b] = (stego[i,j] & deMasking_factor) << (8 - Level*(s+1))


            if s == numbers-1 :
              b += 1

            index += 1

            if b == width :
                b = 0
                a = a+1

    REConstruct(secrets,output_path)



def REConstruct(secret_Image_matrix, output_path) :
    height ,width = secret_Image_matrix[0].shape[:2]
    recombined_image = np.zeros_like(secret_Image_matrix[0])

    for i in range(height) :
        for j in range(width) :
                sum = 0
                for x in range(len(secret_Image_matrix)) :
                    sum += secret_Image_matrix[x][i,j]
                recombined_image[i, j] = sum
    Write_image(output_path, recombined_image)
    print(f"Reconstructed image saved as {output_path}")

def Start_Encode(cover_image_path,secret_image_path,output_image_path) :
    cover_image = Read_image(cover_image_path)
    secret_image = Read_image(secret_image_path)
    Level = Triggering_Level(cover_image_path,secret_image_path)
    Binary_Matrix = image_to_binary_3D(secret_image)
    Bitted_Matrix = Divider(Binary_Matrix)
    Bitted_Matrix = np.array(Bitted_Matrix)
    code = ENCode_lsb(cover_image_path,Bitted_Matrix,Binary_Matrix,output_image_path,Level)
    print(code,Level)
    return code,Level

